# CLAUDE.md

## 重要な制約事項

- ユーザーとのやりとりは日本語で行います
- プログラム中のコメントは日本語で記述します
- コミットメッセージは日本語で記述します
- Pull Request の内容は日本語で記述します
- CLI コマンドを実行する際はフルパスを利用する

## フォルダ構造

```text
root/
├── src/                 # プログラミングコードを実装するフォルダ
├── docs/                # ドキュメントが格納されているフォルダ
│   └── specification.md # 仕様書
├── CLAUDE.md            # ClaudeCodeへの指示が書かれているファイル
└── README.md            # このプロジェクトのREADME
```

## 技術構成

- **プログラミング言語 :** Go v1.24.4

## 実装ステップ

1. **main ブランチを最新に更新する :** `git switch main && git pull origin main` コマンドを実行し main ブランチを最新にする
2. **実装用ブランチを作成し、切り替える :** `git checkout -b [作業内容に沿ったブランチ名]` コマンドを実行し、作業ブランチに切り替える
3. **テスト用のファイルを作成 :** テスト用のファイルを作成する
4. **テストのTODOリストを記述 :** テストする内容をテストファイルのクラスコメントにチェックリスト形式で記載する
5. **コミットを行う :** テスト項目が確定した段階のコミットを行う
6. **TODOリストの順に全ての項目にチェックが着くまで以下の作業を繰り返す :**
     1. **テストコードのみを実装する。コメントでどのTODOに対応するのかわかるようにすること。**
     2. **テストを実行しエラーになることを確認する**
     3. **エラーを解消する実装を行う**
     4. **テストを実行し、成功するまで実装・修正を行う**
     5. **実装中に新たにテストが必要な部分がある場合はTODOリストに追加する**
     6. **テストが成功したらTODOリストをチェック状態にする**
     7. **この時点で存在する全てのテストコード、実装コードをレビューし重複している箇所がある場合はリファクタリングタスクをTODOリストに追加する。この時点ではリファクタリングを実装しない。**
     8. **リファクタリングタスクに必要なテスト内容をTODOリストに追加する。この時点では実装しない。**
     9. **`git commit -m {作業内容}` コマンドでコミットする**
7. **全てのTODOリストにチェックがついることを確認したらテストのカバレッジを確認します :** 80%から100%になるようにします。カバレッジが足りない場合はTODOリストに追加し、6の工程を繰り返します
8. **カバレッジが規定値に到達したらプルリクエストを作成する :** プルリクエストを作成し、レビューを依頼します

## リファクタリング指針

### コード重複の判定基準
- **完全重複**: 同じロジックが複数箇所に記述されている場合は必ず統合する
- **ラッパーメソッド**: 型固有の戻り値が必要でない場合は、基底クラスのメソッドを直接使用する
- **不要なメソッド**: 基底クラスで提供される機能と同じで、型変換のみを行っているメソッドは削除対象

### リファクタリング実行ルール
1. **包括的なリファクタリング**: 実装コードとテストコードの両方を改善対象とする
2. **安全な段階的アプローチ**:
   - Step1: 重複・冗長箇所を特定・分析する
   - Step2: テストコードを新しい構造に対応するよう修正する
   - Step3: 修正後のテストが成功することを確認する
   - Step4: 実装コードから冗長部分を削除・統合する
   - Step5: 全テストが成功することを最終確認する
3. **言語特性の活用**: 使用言語の継承・埋め込み・インターフェース機能を最大限活用する
4. **設計原則の遵守**: DRY原則、単一責任原則、開放閉鎖原則に従った設計にする
5. **テスト品質の向上**: 重複テストの統合、パラメータ化テスト、データ駆動テストの活用

### 一般的なリファクタリングパターン

#### 1. **メソッドの重複排除**
- **問題**: 複数のクラスで同じロジックのメソッドが存在
- **解決**: 基底クラス/インターフェースに共通メソッドを定義し、派生クラスから削除
- **例**: `子クラス.メソッド()` → `子クラス.基底クラス.メソッド()` または埋め込みによる自動継承

#### 2. **不要なラッパーメソッドの削除**
- **問題**: 基底クラスのメソッドを単純に呼び出すだけのメソッド
- **解決**: ラッパーメソッドを削除し、基底クラスのメソッドを直接使用
- **判断基準**: 型変換や追加ロジックがない場合は削除対象

#### 3. **テストコードの重複統合**
- **問題**: 同じパターンのテストが複数存在
- **解決**: テーブル駆動テストやパラメータ化テストに統合
- **効果**: テスト保守性向上とテストケース追加の簡素化

#### 4. **共通インターフェースの抽出**
- **問題**: 複数のクラスが同じメソッドセットを実装
- **解決**: 共通インターフェースを定義し、実装を統一
- **効果**: 多態性の活用と依存関係の疎結合化

### リファクタリング品質指標
- **コード重複率**: 同じロジックの重複を最小化（目標：5%以下）
- **テストカバレッジ**: リファクタリング後も同レベル以上を維持
- **循環的複雑度**: メソッドの複雑度を適切なレベルに保つ
- **結合度**: クラス間の依存関係を疎結合に保つ
- **凝集度**: 各クラス・メソッドの責任範囲を明確にする

